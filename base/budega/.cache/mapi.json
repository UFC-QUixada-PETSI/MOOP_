{
    "title": "@budega: Gerencie a fila de espera e atendimento",
    "description": "# Gerencie a fila de espera e atendimento\n\n<!-- toch -->\n[Intro](#intro) | [Guide](#guide) | [Answers](#answers) | [Shell](#shell) | [Draft](#draft)\n-- | -- | -- | -- | --\n<!-- toch -->\n\n![cover](https://raw.githubusercontent.com/qxcodepoo/arcade/master/base/budega/cover.jpg)\n\n## Intro\n\nEste \u00e9 um projeto de modelagem e implementa\u00e7\u00e3o de um mercantil, que simula o funcionamento de caixas de atendimento e uma fila de espera. Para isso, ser\u00e3o implementadas duas classes principais: Pessoa `Person` e Mercado `Market`.\n\n- A classe `Market` representa o estabelecimento, com atributos como caixas de atendimento `counters` e uma fila de espera de clientes `wainting`.\n- Os caixas `counters` s\u00e3o modelados como um vetor de clientes de tamanho fixo. Uma posi\u00e7\u00e3o do caixa ter\u00e1 o valor `null` para indicar que o caixa est\u00e1 vazio ou ter\u00e1 um objeto cliente.\n  - typescript: `counters: (Person | null)[]`\n  - java: `ArrayList<Person> counters`\n  - cpp: `vector<Person*> counters`\n- A fila de espera `queue` \u00e9 uma lista de clientes de tamanho vari\u00e1vel. Todo cliente que chega \u00e9 inserido no final da fila. Todo cliente que \u00e9 chamado para um caixa \u00e9 removido do in\u00edcio da fila.\n  - typescript: `waiting: Person[]`\n  - java: `LinkedList<Person> waiting`\n  - cpp: `list<Person*> waiting`\n- As opera\u00e7\u00f5es principais incluem chegar cliente `arrive`, chamar no caixa `call` e finalizar atendimento `finish`.\n- As opera\u00e7\u00f5es \"b\u00f4nus\" s\u00e3o furar fila `cutInLine` e abandonar fila de espera `giveup`.\n\n### Comandos\n\nTodos os comandos seguem o modelo `$comando arg1 arg2 ...`. Em caso de erro, uma mensagem adequada deve ser impressa.\n\n- `$show` - Mostra o estado atual do mercantil, incluindo os clientes nos caixas e na fila de espera.\n- `$init` - Reinicia o estado do mercantil, definindo a quantidade de caixas e limpando a fila de espera.\n- `$enter` - Adiciona um cliente \u00e0 fila de espera. Deve ser seguido pelo nome do cliente.\n- `$call` - Chama o pr\u00f3ximo cliente na fila de espera para um caixa dispon\u00edvel. Deve ser seguido pelo n\u00famero do caixa.\n- `$finish` - Finaliza o atendimento de um cliente em um caixa. Deve ser seguido pelo n\u00famero do caixa.\n\n## Guide\n\n![diagrama](https://raw.githubusercontent.com/qxcodepoo/arcade/master/base/budega/diagrama.png)\n\n### Parte 1: Classe Cliente\n\n- Crie a classe `Cliente` com os atributos `nome`.\n- Defina os atributos como privados.\n- Crie o construtor da classe que recebe o `nome` como uma string.\n- Crie o m\u00e9todo `getNome()` para retornar o nome do cliente.\n- Crie o m\u00e9todo `toString()` para retornar uma string no formato \"nome\".\n\n### Parte 2: Classe Mercantil\n\n#### Construtor\n\n- Implemente o construtor da classe `Market`, que recebe a quantidade de caixas como par\u00e2metro.\n- Inicialize os atributos da classe, incluindo o vetor de caixas e a fila de espera.\n- Preencha o vetor de caixas com `null` para indicar que todos os caixas est\u00e3o vazios.\n\n#### M\u00e9todo `toString()`\n\n- Implemente o m\u00e9todo `toString()` para retornar uma representa\u00e7\u00e3o em string do estado atual do mercantil. Exemplo\n\n```txt\nCaixas: [-----, -----]\nEspera: [carla, maria, rubia]\n```\n\n- Pesquise na sua linguagem e aprenda a utilizar os m\u00e9todos map, join se existirem.\n- Use a fun\u00e7\u00e3o `map()` para percorrer o vetor de caixas e a fila de espera e criar uma string que represente cada caixa e cada cliente na fila.\n- Utilize if e else ou operador tern\u00e1rio para verificar se cada caixa est\u00e1 vazio ou ocupado e ajustar a representa\u00e7\u00e3o de acordo.\n- Junte as strings individuais de cada caixa e da fila de espera usando o m\u00e9todo `join()` para criar uma representa\u00e7\u00e3o coerente do estado do mercantil.\n- Retorne a string resultante.\n\n### Parte 3: Chegar\n\n- Na classe `Market`, crie o m\u00e9todo `arrive(person: Person): void` que permite que uma pessoa chegue na fila de espera.\n- Adicione a pessoa ao final da fila de espera.\n\n### Parte 4: Chamar Cliente\n\n- Na classe `Market`, crie o m\u00e9todo `call(index: number): void` que permite chamar o primeiro cliente da lista de espera para ser atendido em um caixa espec\u00edfico.\n- Se n\u00e3o houver ningu\u00e9m na fila de espera, emita a mensagem de erro \"fail: sem clientes\".\n- Se o caixa estiver ocupado, imprima a mensagem de erro \"fail: caixa ocupado\".\n\n### Parte 5: Finalizar Atendimento\n\n- Na classe `Market`, crie o m\u00e9todo `finish(index: number): Pessoa | null` que permite finalizar o atendimento de um cliente em um caixa espec\u00edfico.\n- Verifique se o \u00edndice do caixa \u00e9 v\u00e1lido e, se n\u00e3o for, emita a mensagem de erro `fail: caixa inexistente`.\n- Verifique se h\u00e1 algu\u00e9m sendo atendido no caixa. Se n\u00e3o houver, emita a mensagem de erro `fail: caixa vazio`.\n- Retorne o cliente que foi atendido e libere o caixa, definindo-o como null.\n\n## Answers\n\n[![_](https://raw.githubusercontent.com/qxcodepoo/arcade/master/base/budega/../../wiki/images/resolucao.png)](https://youtu.be/Z7karsbg1ok)\n\n## Shell\n\n```sh\n#TEST_CASE iniciar\n\n$init 2\n$show\nCaixas: [-----, -----]\nEspera: []\n\n#TEST_CASE arrive\n\n$arrive carla\n$arrive maria\n$arrive rubia\n\n$show\nCaixas: [-----, -----]\nEspera: [carla, maria, rubia]\n\n#TEST_CASE call\n\n$call 0\n$show\nCaixas: [carla, -----]\nEspera: [maria, rubia]\n\n#TEST_CASE finish\n\n$finish 0\n$show\nCaixas: [-----, -----]\nEspera: [maria, rubia]\n\n$end\n\n```\n\n```sh\n#TEST_CASE iniciar2\n\n$init 3\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n\n$arrive carla\n$arrive maria\n\n$show\nCaixas: [-----, -----, -----]\nEspera: [carla, maria]\n\n#TEST_CASE call\n\n$call 0\n$call 0\nfail: caixa ocupado\n$show\nCaixas: [carla, -----, -----]\nEspera: [maria]\n\n#TEST_CASE empty waiting\n\n$call 2\n$show\nCaixas: [carla, -----, maria]\nEspera: []\n\n#TEST_CASE empty waiting\n\n$call 1\nfail: sem clientes\n\n#TEST_CASE finish\n\n$finish 0\n$show\nCaixas: [-----, -----, maria]\nEspera: []\n\n$finish 2\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n\n#TEST_CASE error\n\n$finish 3\nfail: caixa inexistente\n$finish 1\nfail: caixa vazio\n\n$end\n\n```\n\n## Draft\n\n<!-- links .cache/draft -->\n- cpp\n  - [shell.cpp](https://github.com/qxcodepoo/arcade/blob/master/base/budega/.cache/draft/cpp/shell.cpp)\n- go\n  - [shell.go](https://github.com/qxcodepoo/arcade/blob/master/base/budega/.cache/draft/go/shell.go)\n- java\n  - [Shell.java](https://github.com/qxcodepoo/arcade/blob/master/base/budega/.cache/draft/java/Shell.java)\n- ts\n  - [shell.ts](https://github.com/qxcodepoo/arcade/blob/master/base/budega/.cache/draft/ts/shell.ts)\n<!-- links -->\n",
    "upload": [
        {
            "name": "vpl_evaluate.cases",
            "contents": ">>>>>>>> INSERT iniciar\ninit 2\nshow\nend\n======== EXPECT\n$init 2\n$show\nCaixas: [-----, -----]\nEspera: []\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT arrive\ninit 2\nshow\narrive carla\narrive maria\narrive rubia\nshow\nend\n======== EXPECT\n$init 2\n$show\nCaixas: [-----, -----]\nEspera: []\n$arrive carla\n$arrive maria\n$arrive rubia\n$show\nCaixas: [-----, -----]\nEspera: [carla, maria, rubia]\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT call\ninit 2\nshow\narrive carla\narrive maria\narrive rubia\nshow\ncall 0\nshow\nend\n======== EXPECT\n$init 2\n$show\nCaixas: [-----, -----]\nEspera: []\n$arrive carla\n$arrive maria\n$arrive rubia\n$show\nCaixas: [-----, -----]\nEspera: [carla, maria, rubia]\n$call 0\n$show\nCaixas: [carla, -----]\nEspera: [maria, rubia]\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT finish\ninit 2\nshow\narrive carla\narrive maria\narrive rubia\nshow\ncall 0\nshow\nfinish 0\nshow\nend\n======== EXPECT\n$init 2\n$show\nCaixas: [-----, -----]\nEspera: []\n$arrive carla\n$arrive maria\n$arrive rubia\n$show\nCaixas: [-----, -----]\nEspera: [carla, maria, rubia]\n$call 0\n$show\nCaixas: [carla, -----]\nEspera: [maria, rubia]\n$finish 0\n$show\nCaixas: [-----, -----]\nEspera: [maria, rubia]\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT iniciar2\ninit 3\nshow\narrive carla\narrive maria\nshow\nend\n======== EXPECT\n$init 3\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n$arrive carla\n$arrive maria\n$show\nCaixas: [-----, -----, -----]\nEspera: [carla, maria]\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT call\ninit 3\nshow\narrive carla\narrive maria\nshow\ncall 0\ncall 0\nshow\nend\n======== EXPECT\n$init 3\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n$arrive carla\n$arrive maria\n$show\nCaixas: [-----, -----, -----]\nEspera: [carla, maria]\n$call 0\n$call 0\nfail: caixa ocupado\n$show\nCaixas: [carla, -----, -----]\nEspera: [maria]\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT empty waiting\ninit 3\nshow\narrive carla\narrive maria\nshow\ncall 0\ncall 0\nshow\ncall 2\nshow\nend\n======== EXPECT\n$init 3\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n$arrive carla\n$arrive maria\n$show\nCaixas: [-----, -----, -----]\nEspera: [carla, maria]\n$call 0\n$call 0\nfail: caixa ocupado\n$show\nCaixas: [carla, -----, -----]\nEspera: [maria]\n$call 2\n$show\nCaixas: [carla, -----, maria]\nEspera: []\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT empty waiting\ninit 3\nshow\narrive carla\narrive maria\nshow\ncall 0\ncall 0\nshow\ncall 2\nshow\ncall 1\nend\n======== EXPECT\n$init 3\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n$arrive carla\n$arrive maria\n$show\nCaixas: [-----, -----, -----]\nEspera: [carla, maria]\n$call 0\n$call 0\nfail: caixa ocupado\n$show\nCaixas: [carla, -----, -----]\nEspera: [maria]\n$call 2\n$show\nCaixas: [carla, -----, maria]\nEspera: []\n$call 1\nfail: sem clientes\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT finish\ninit 3\nshow\narrive carla\narrive maria\nshow\ncall 0\ncall 0\nshow\ncall 2\nshow\ncall 1\nfinish 0\nshow\nfinish 2\nshow\nend\n======== EXPECT\n$init 3\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n$arrive carla\n$arrive maria\n$show\nCaixas: [-----, -----, -----]\nEspera: [carla, maria]\n$call 0\n$call 0\nfail: caixa ocupado\n$show\nCaixas: [carla, -----, -----]\nEspera: [maria]\n$call 2\n$show\nCaixas: [carla, -----, maria]\nEspera: []\n$call 1\nfail: sem clientes\n$finish 0\n$show\nCaixas: [-----, -----, maria]\nEspera: []\n$finish 2\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT error\ninit 3\nshow\narrive carla\narrive maria\nshow\ncall 0\ncall 0\nshow\ncall 2\nshow\ncall 1\nfinish 0\nshow\nfinish 2\nshow\nfinish 3\nfinish 1\nend\n======== EXPECT\n$init 3\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n$arrive carla\n$arrive maria\n$show\nCaixas: [-----, -----, -----]\nEspera: [carla, maria]\n$call 0\n$call 0\nfail: caixa ocupado\n$show\nCaixas: [carla, -----, -----]\nEspera: [maria]\n$call 2\n$show\nCaixas: [carla, -----, maria]\nEspera: []\n$call 1\nfail: sem clientes\n$finish 0\n$show\nCaixas: [-----, -----, maria]\nEspera: []\n$finish 2\n$show\nCaixas: [-----, -----, -----]\nEspera: []\n$finish 3\nfail: caixa inexistente\n$finish 1\nfail: caixa vazio\n$end\n<<<<<<<< FINISH\n\n",
            "type": "hide"
        }
    ],
    "draft": {
        "ts": [
            {
                "name": "shell.ts",
                "contents": "const input = () => \"\"; // MODO_TESTE\nexport {};\n\nfunction main() {\n    while (true) {\n        const line = input();\n        console.log(\"$\" + line);\n\n        var par = line.split(\" \");\n        var cmd = par[0];\n\n        if (cmd == \"end\") {\n            break;\n        } else if (cmd == \"show\") { \n        } else if (cmd == \"init\") { \n            // const nCaixas = parseInt(par[1]);\n        } else if (cmd == \"arrive\") { \n            // const nome = par[1];\n        } else if (cmd == \"call\") { \n            // const index = parseInt(par[1]);\n        } else if (cmd == \"finish\") { \n            // const index = parseInt(par[1]);\n        } else {\n            console.log(\"fail: comando invalido\");\n        }\n    }\n}\nmain() \n",
                "type": "show"
            }
        ],
        "java": [
            {
                "name": "Shell.java",
                "contents": "import java.util.*;\n\n\nclass Shell {\n    public static void main(String[] _args) {\n        while(true) {\n            var line = scanner.nextLine();\n            System.out.println(\"$\" + line);\n\n            var par = line.split(\" \");\n            var cmd = par[0];\n\n            if (cmd.equals(\"end\")) {\n                break;\n            }\n            else if (cmd.equals(\"init\")) { \n                // var qtd_caixas = Integer.parseInt(par[1]);\n            }\n            else if (cmd.equals(\"show\")) { \n            }\n            else if (cmd.equals(\"arrive\")) { \n                // var nome = par[1];\n            }\n            else if (cmd.equals(\"call\")) { \n                // var indice = Integer.parseInt(par[1]);\n            }\n            else if (cmd.equals(\"finish\")) { \n                // var indice = Integer.parseInt(par[1]);\n            }\n            else {\n                System.out.println(\"fail: comando invalido\");\n\n            }\n        }\n    }\n\n    static Scanner scanner = new Scanner(System.in);\n}\n",
                "type": "show"
            }
        ],
        "cpp": [
            {
                "name": "shell.cpp",
                "contents": "#include <iostream>\n#include <vector>\n#include <list>\n#include <memory>\n#include <sstream>\n#include <utility>\nusing namespace std;\n\n\n// Fun\u00e7\u00e3o auxiliar para mapear e juntar elementos de um container\ntemplate <typename CONTAINER, typename FUNC>\nauto map_join(const CONTAINER& c, FUNC f, const string& sep = \", \") {\n    stringstream ss;\n    for (auto it = c.begin(); it != c.end(); ++it) {\n        ss << (it != c.begin() ? sep : \"\") << f(*it);\n    }\n    return ss.str();\n}\n\nint main() {\n    while (true) {\n        string line, cmd;\n        getline(cin, line);\n        cout << \"$\" << line << endl;\n\n        stringstream ss(line);\n        ss >> cmd;\n\n        if (cmd == \"end\") {\n            break;\n        } else if (cmd == \"show\") { \n        } else if (cmd == \"init\") { \n            // int qtd_caixas;\n            // ss >> qtd_caixas;\n        } else if (cmd == \"arrive\") { \n            // string nome;\n            // ss >> nome;\n        } else if (cmd == \"call\") { \n            // int indice;\n            // ss >> indice;\n        } else if (cmd == \"finish\") { \n            // int indice;\n            // ss >> indice;\n        } else {\n            cout << \"fail: comando invalido\\n\";\n        }\n    }\n}\n",
                "type": "show"
            }
        ],
        "go": [
            {
                "name": "shell.go",
                "contents": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfor {\n\t\tif !scanner.Scan() { // read line and store in scanner buffer\n\t\t\tbreak\n\t\t}\n\t\tline := scanner.Text() // get the line from the scanner buffer into a string\n\t\tfmt.Println(\"$\" + line)\n\n\t\tparts := strings.Fields(line)\n\t\tcmd := parts[0]\n\n\t\tswitch cmd {\n\t\tcase \"end\":\n\t\t\tbreak\n\t\tcase \"show\":\n\t\tcase \"init\":\n\t\t\tqtd, _ := strconv.Atoi(parts[1])\n\t\t\t_ = qtd\n\t\tcase \"arrive\":\n\t\t\tname := parts[1]\n\t\t\t_ = name\n\t\tcase \"call\":\n\t\t\tindex, _ := strconv.Atoi(parts[1])\n\t\t\t_ = index\n\t\tcase \"finish\":\n\t\t\tindex, _ := strconv.Atoi(parts[1])\n\t\t\t_ = index\n\t\tdefault:\n\t\t\tfmt.Println(\"fail: comando invalido\")\n\t\t}\n\t}\n}\n",
                "type": "show"
            }
        ]
    }
}
